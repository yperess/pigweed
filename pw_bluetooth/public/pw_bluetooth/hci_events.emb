# Copyright 2023 The Pigweed Authors
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.

# This file contains Emboss definitions for Host Controller Interface packets
# and types found in the Bluetooth Core Specification. The Emboss compiler is
# used to generate a C++ header from this file.

import "pw_bluetooth/hci_common.emb" as hci

[$default byte_order: "LittleEndian"]
[(cpp) namespace: "pw::bluetooth::emboss"]
# =========================== Constants =================================


enum CoreSpecificationVersion:
  -- Bluetooth Core Specification version
  [maximum_bits: 8]
  V1_0B    = 0x00  # v1.0b
  V1_1     = 0x01  # v1.1
  V1_2     = 0x02  # v1.2
  V2_0_EDR = 0x03  # v2.0+EDR
  V2_1_EDR = 0x04  # v2.0+EDR
  V3_0_HS  = 0x05  # v3.0+HS
  V4_0     = 0x06  # v4.0
  V4_1     = 0x07  # v4.1
  V4_2     = 0x08  # v4.2
  V5_0     = 0x09  # v5.0
  V5_1     = 0x0A  # v5.1
  V5_2     = 0x0B  # v5.2
  V5_3     = 0x0C  # v5.3
  V5_4     = 0x0D  # v5.4


enum LinkType:
  [maximum_bits: 8]
  SCO  = 0x00
  ACL  = 0x01
  ESCO = 0x02


enum EncryptionStatus:
  OFF                                = 0x00
  ON_WITH_E0_FOR_BREDR_OR_AES_FOR_LE = 0x01
  ON_WITH_AES_FOR_BREDR              = 0x02


enum LEAdvertisingDataStatus:
  [maximum_bits: 2]
  COMPLETE             = 0b00
  INCOMPLETE           = 0b01
  INCOMPLETE_TRUNCATED = 0b10


enum LEDirectAddressType:
  -- Possible values that can be reported for the |direct_address_type| parameter in LE Advertising
  -- Report events.
  [maximum_bits: 8]
  PUBLIC                                = 0x00
    -- Public Device Address

  PRIVATE                               = 0x01
    -- Non-resolvable Private Address or Static Device Address

  RESOLVABLE_PRIVATE_OWN_ADDRESS_PUBLIC = 0x02
    -- Resolvable Private Address (resolved by Controller; Own_Address_Type was 0x00 or 0x02)

  RESOLVABLE_PRIVATE_OWN_ADDRESS_RANDOM = 0x03
    -- Resolvable Private Address (resolved by Controller; Own_Address_Type was 0x01 or 0x03)

  RESOLVABLE_PRIVATE                    = 0xFE
    -- Resolvable Private Address (Controller unable to resolve)


enum LEClockAccuracy:
  -- Possible values that can be reported for the |central_clock_accuracy| and
  -- |advertiser_clock_accuracy| parameters.
  [maximum_bits: 8]
  PPM_500 = 0x00
  PPM_250 = 0x01
  PPM_150 = 0x02
  PPM_100 = 0x03
  PPM_75  = 0x04
  PPM_50  = 0x05
  PPM_30  = 0x06
  PPM_20  = 0x07


enum KeyType:
  -- The key type used during pairing.
  [maximum_bits: 8]
  COMBINATION                           = 0x00
  DEBUG_COMBINATION                     = 0x03
  UNAUTHENTICATED_COMBINATION_FROM_P192 = 0x04
  AUTHENTICATED_COMBINATION_FROM_P192   = 0x05
  CHANGED_COMBINATION_KEY               = 0x06
  UNAUTHENTICATED_COMBINATION_FROM_P256 = 0x07
  AUTHENTICATED_COMBINATION_FROM_P256   = 0x08


enum IsoPhyType:
  -- The PHY used for transmitting ISO frames
  [maximum_bits: 8]
  LE_1M    = 0x01
  LE_2M    = 0x02
  LE_CODED = 0x03

# =========================== Field Types =================================


bits LmpFeatures(page: UInt:8):
  -- Bit mask of Link Manager Protocol features.
  [requires: page <= 2]
  if page == 0:
    0  [+1]  Flag  three_slot_packets
    1  [+1]  Flag  five_slot_packets
    2  [+1]  Flag  encryption
    3  [+1]  Flag  slot_offset
    4  [+1]  Flag  timing_accuracy
    5  [+1]  Flag  role_switch
    6  [+1]  Flag  hold_mode
    7  [+1]  Flag  sniff_mode
    # 8: previously used
    9  [+1]  Flag  power_control_requests
    10 [+1]  Flag  channel_quality_driven_data_rate
    11 [+1]  Flag  sco_link
    12 [+1]  Flag  hv2_packets
    13 [+1]  Flag  hv3_packets
    14 [+1]  Flag  mu_law_log_synchronous_data
    15 [+1]  Flag  a_law_log_synchronous_data
    16 [+1]  Flag  cvsd_synchronous_data
    17 [+1]  Flag  paging_parameter_negotiation
    18 [+1]  Flag  power_control
    19 [+1]  Flag  transparent_synchronous_data
    20 [+3]  UInt  flow_control_lag
    23 [+1]  Flag  broadcast_encryption
    # 24: reserved for future use
    25 [+1]  Flag  enhanced_data_rate_acl_2_mbs_mode
    26 [+1]  Flag  enhanced_data_rate_acl_3_mbs_mode
    27 [+1]  Flag  enhanced_inquiry_scan
    28 [+1]  Flag  interlaced_inquiry_scan
    29 [+1]  Flag  interlaced_page_scan
    30 [+1]  Flag  rssi_with_inquiry_results
    31 [+1]  Flag  extended_sco_link_ev3_packets
    32 [+1]  Flag  ev4_packets
    33 [+1]  Flag  ev5_packets
    # 34: reserved for future use
    35 [+1]  Flag  afh_capable_peripheral
    36 [+1]  Flag  afh_classification_peripheral
    37 [+1]  Flag  bredr_not_supported
    38 [+1]  Flag  le_supported_controller
    39 [+1]  Flag  three_slot_enhanced_data_rate_acl_packets
    40 [+1]  Flag  five_slot_enhanced_data_rate_acl_packets
    41 [+1]  Flag  sniff_subrating
    42 [+1]  Flag  pause_encryption
    43 [+1]  Flag  afh_capable_central
    44 [+1]  Flag  afh_classification_central
    45 [+1]  Flag  enhanced_data_rate_esco_2_mbs_mode
    46 [+1]  Flag  enhanced_data_rate_esco_3_mbs_mode
    47 [+1]  Flag  three_slot_enhanced_data_rate_esco_packets
    48 [+1]  Flag  extended_inquiry_response
    49 [+1]  Flag  simultaneous_le_and_bredr_to_same_device_capable_controller
    # 50: reserved for future use
    51 [+1]  Flag  secure_simple_pairing_controller_support
    52 [+1]  Flag  encapsulated_pdu
    53 [+1]  Flag  erroneous_data_reporting
    54 [+1]  Flag  non_flushable_packet_boundary_flag
    # 55: reserved for future use
    56 [+1]  Flag  hci_link_supervision_timeout_changed_event
    57 [+1]  Flag  variable_inquiry_tx_power_level
    58 [+1]  Flag  enhanced_power_control
    # 59-62: reserved for future use
    63 [+1]  Flag  extended_features

  if page == 1:
    0  [+1]  Flag  secure_simple_pairing_host_support
    1  [+1]  Flag  le_supported_host
    # 2: previously used
    3  [+1]  Flag  secure_connection_host_support

  if page == 2:
    0  [+1]  Flag  connectionless_peripheral_broadcast_transmitter_operation
    1  [+1]  Flag  connectionless_peripheral_broadcast_receiver_operation
    2  [+1]  Flag  synchronization_train
    3  [+1]  Flag  synchronization_scan
    4  [+1]  Flag  hci_inquiry_response_notification_event
    5  [+1]  Flag  generalized_interlaced_scan
    6  [+1]  Flag  coarse_clock_adjustment
    # 7: reserved for future use
    8  [+1]  Flag  secure_connections_controller_support
    9  [+1]  Flag  ping
    10 [+1]  Flag  slot_availability_mask
    11 [+1]  Flag  train_nudging


bits LEFeatureSet:
  0     [+1]  Flag  le_encryption
  $next [+1]  Flag  connection_parameters_request_procedure
  $next [+1]  Flag  extended_reject_indication
  $next [+1]  Flag  peripheral_initiated_features_exchange
  $next [+1]  Flag  le_ping
  $next [+1]  Flag  le_data_packet_length_extension
  $next [+1]  Flag  ll_privacy
  $next [+1]  Flag  extended_scanning_filter_policies
  $next [+1]  Flag  le_2m_phy
  $next [+1]  Flag  stable_modulation_index_transmitter
  $next [+1]  Flag  stable_modulation_index_receiver
  $next [+1]  Flag  le_coded_phy
  $next [+1]  Flag  le_extended_advertising
  $next [+1]  Flag  le_periodic_advertising
  $next [+1]  Flag  channel_selection_algorithm_2
  $next [+1]  Flag  le_power_class_1
  $next [+1]  Flag  minimum_number_of_used_channels_procedure
  $next [+1]  Flag  connection_cte_request
  $next [+1]  Flag  connection_cte_response
  $next [+1]  Flag  connectionless_cte_transmitter
  $next [+1]  Flag  connectionless_cte_receiver
  $next [+1]  Flag  antenna_switching_during_cte_transmission
  $next [+1]  Flag  antenna_switching_during_cte_reception
  $next [+1]  Flag  receiving_constant_tone_extensions
  $next [+1]  Flag  periodic_advertising_sync_transfer_sender
  $next [+1]  Flag  periodic_advertising_sync_transfer_recipient
  $next [+1]  Flag  sleep_clock_accuracy_updates
  $next [+1]  Flag  remote_public_key_validation
  $next [+1]  Flag  connected_isochronous_stream_central
  $next [+1]  Flag  connected_isochronous_stream_peripheral
  $next [+1]  Flag  isochronous_broadcaster
  $next [+1]  Flag  synchronized_receiver
  $next [+1]  Flag  connected_isochronous_stream_host_support
  $next [+1]  Flag  le_power_control_request_1
  $next [+1]  Flag  le_power_control_request_2
    -- Previous two bits shall always have the same value.

  $next [+1]  Flag  le_path_loss_monitoring
  $next [+1]  Flag  periodic_advertising_adi_support
  $next [+1]  Flag  connection_subrating
  $next [+1]  Flag  connection_subrating_host_support
  $next [+1]  Flag  channel_classification
  $next [+1]  Flag  advertising_coding_selection
  $next [+1]  Flag  advertising_coding_selection_host_support
  $next [+1]  Flag  reserved                                        # Bit 42 is skipped
  $next [+1]  Flag  periodic_advertising_with_responses_advertiser
  $next [+1]  Flag  periodic_advertising_with_responses_scanner


enum LEAdvertisingEventType:
  [maximum_bits: 8]
  CONNECTABLE_AND_SCANNABLE_UNDIRECTED = 0x00
    -- ADV_IND

  CONNECTABLE_DIRECTED                 = 0x01
    -- ADV_DIRECT_IND

  SCANNABLE_UNDIRECTED                 = 0x02
    --  ADV_SCAN_IND

  NON_CONNECTABLE_UNDIRECTED           = 0x03
    -- ADV_NONCONN_IND

  SCAN_RESPONSE                        = 0x04
    -- SCAN_RSP


bits LEExtendedAdvertisingEventType:
  0     [+1]  Flag                     connectable
  $next [+1]  Flag                     scannable
  $next [+1]  Flag                     directed
  $next [+1]  Flag                     scan_response
  $next [+1]  Flag                     legacy
  $next [+2]  LEAdvertisingDataStatus  data_status


bits SupportedCommands(octet: UInt:8):
  [requires: octet <= 47]
  if octet == 0:
    0 [+1]  Flag  inquiry
    1 [+1]  Flag  inquiry_cancel
    2 [+1]  Flag  periodic_inquiry_mode
    3 [+1]  Flag  exit_periodic_inquiry_mode
    4 [+1]  Flag  create_connection
    5 [+1]  Flag  disconnect
    7 [+1]  Flag  create_connection_cancel

  if octet == 1:
    0 [+1]  Flag  accept_connection_request
    1 [+1]  Flag  reject_connection_request
    2 [+1]  Flag  link_key_request_reply
    3 [+1]  Flag  link_key_request_negative_reply
    4 [+1]  Flag  pin_code_request_reply
    5 [+1]  Flag  pin_code_request_negative_reply
    6 [+1]  Flag  change_connection_packet_type
    7 [+1]  Flag  authentication_requested

  if octet == 2:
    0 [+1]  Flag  set_connection_encryption
    1 [+1]  Flag  change_connection_link_key
    2 [+1]  Flag  link_key_selection
    3 [+1]  Flag  remote_name_request
    4 [+1]  Flag  remote_name_request_cancel
    5 [+1]  Flag  read_remote_supported_features
    6 [+1]  Flag  read_remote_extended_features
    7 [+1]  Flag  read_remote_version_information

  if octet == 3:
    0 [+1]  Flag  read_clock_offset
    1 [+1]  Flag  read_lmp_handle

  if octet == 4:
    1 [+1]  Flag  hold_mode
    2 [+1]  Flag  sniff_mode
    3 [+1]  Flag  exit_sniff_mode
    6 [+1]  Flag  qos_setup
    7 [+1]  Flag  role_discovery

  if octet == 5:
    0 [+1]  Flag  switch_role
    1 [+1]  Flag  read_link_policy_settings
    2 [+1]  Flag  write_link_policy_settings
    3 [+1]  Flag  read_default_link_policy_settings
    4 [+1]  Flag  write_default_link_policy_settings
    5 [+1]  Flag  flow_specification
    6 [+1]  Flag  set_event_mask
    7 [+1]  Flag  reset

  if octet == 6:
    0 [+1]  Flag  set_event_filter
    1 [+1]  Flag  flush
    2 [+1]  Flag  read_pin_type
    3 [+1]  Flag  write_pin_type
    5 [+1]  Flag  read_stored_link_key
    6 [+1]  Flag  write_stored_link_key
    7 [+1]  Flag  deleted_stored_link_key

  if octet == 7:
    0 [+1]  Flag  write_local_name
    1 [+1]  Flag  read_local_name
    2 [+1]  Flag  read_connection_attempt_timeout
    3 [+1]  Flag  write_connection_attempt_timeout
    4 [+1]  Flag  read_page_timeout
    5 [+1]  Flag  write_page_timeout
    6 [+1]  Flag  read_scan_enable
    7 [+1]  Flag  write_scan_enable

  if octet == 8:
    0 [+1]  Flag  read_page_scan_activity
    1 [+1]  Flag  write_page_scan_activity
    2 [+1]  Flag  read_inquiry_scan_activity
    3 [+1]  Flag  write_inquiry_scan_activity
    4 [+1]  Flag  read_authentication_enable
    5 [+1]  Flag  write_authentication_enable

  if octet == 9:
    0 [+1]  Flag  read_class_of_device
    1 [+1]  Flag  write_class_of_device
    2 [+1]  Flag  read_voice_setting
    3 [+1]  Flag  write_voice_setting
    4 [+1]  Flag  read_automatic_flush_timeout
    5 [+1]  Flag  write_automatic_flush_timeout
    6 [+1]  Flag  read_num_broadcast_retransmissions
    7 [+1]  Flag  write_num_broadcast_retransmissions

  if octet == 10:
    0 [+1]  Flag  read_hold_mode_activity
    1 [+1]  Flag  write_hold_mode_activity
    2 [+1]  Flag  read_transmit_power_level
    3 [+1]  Flag  read_synchronous_flow_control_enable
    4 [+1]  Flag  write_synchronous_flow_control_enable
    5 [+1]  Flag  set_controller_to_host_flow_control
    6 [+1]  Flag  host_buffer_size
    7 [+1]  Flag  host_number_of_completed_packets

  if octet == 11:
    0 [+1]  Flag  read_link_supervision_timeout
    1 [+1]  Flag  write_link_supervision_timeout
    2 [+1]  Flag  read_number_of_supported_iac
    3 [+1]  Flag  read_current_iaclap
    4 [+1]  Flag  write_current_iaclap

  if octet == 12:
    1 [+1]  Flag  set_afh_host_channel_classification
    4 [+1]  Flag  read_inquiry_scan_type
    5 [+1]  Flag  write_inquiry_scan_type
    6 [+1]  Flag  read_inquiry_mode
    7 [+1]  Flag  write_inquiry_mode

  if octet == 13:
    0 [+1]  Flag  read_page_scan_type
    1 [+1]  Flag  write_page_scan_type
    2 [+1]  Flag  read_afh_channel_assessment_mode
    3 [+1]  Flag  write_afh_channel_assessment_mode

  if octet == 14:
    3 [+1]  Flag  read_local_version_information
    5 [+1]  Flag  read_local_supported_features
    6 [+1]  Flag  read_local_extended_features
    7 [+1]  Flag  read_buffer_size

  if octet == 15:
    1 [+1]  Flag  read_bdaddr
    2 [+1]  Flag  read_failed_contact_counter
    3 [+1]  Flag  reset_failed_contact_c_ounter
    4 [+1]  Flag  read_link_quality
    5 [+1]  Flag  read_rssi
    6 [+1]  Flag  read_afh_channel_map
    7 [+1]  Flag  read_clock

  if octet == 16:
    0 [+1]  Flag  read_loopback_mode
    1 [+1]  Flag  write_loopback_mode
    2 [+1]  Flag  enable_device_under_test_mode
    3 [+1]  Flag  setup_synchronous_connection_request
    4 [+1]  Flag  accept_synchronous_connection_request
    5 [+1]  Flag  reject_synchronous_connection_request

  if octet == 17:
    0 [+1]  Flag  read_extended_inquiry_response
    1 [+1]  Flag  write_extended_inquiry_response
    2 [+1]  Flag  refresh_encryption_key
    4 [+1]  Flag  sniff_subrating
    5 [+1]  Flag  read_simple_pairing_mode
    6 [+1]  Flag  write_simple_pairing_mode
    7 [+1]  Flag  read_local_oob_data

  if octet == 18:
    0 [+1]  Flag  read_inquiry_response_transmit_power_level
    1 [+1]  Flag  write_inquiry_transmit_power_level
    2 [+1]  Flag  read_default_erroneous_data_reporting
    3 [+1]  Flag  write_default_erroneous_data_reporting
    7 [+1]  Flag  io_capability_request_reply

  if octet == 19:
    0 [+1]  Flag  user_confirmation_request_reply
    1 [+1]  Flag  user_confirmation_request_negative_reply
    2 [+1]  Flag  user_passkey_request_reply
    3 [+1]  Flag  user_passkey_request_negative_reply
    4 [+1]  Flag  remote_oob_data_request_reply
    5 [+1]  Flag  write_simple_pairing_debug_mode
    6 [+1]  Flag  enhanced_flush
    7 [+1]  Flag  remote_oob_data_request_negative_reply

  if octet == 20:
    2 [+1]  Flag  send_keypress_notification
    3 [+1]  Flag  io_capability_request_negative_reply
    4 [+1]  Flag  read_encryption_key_size

  if octet == 21:
    0 [+1]  Flag  create_physical_link
    1 [+1]  Flag  accept_physical_link
    2 [+1]  Flag  disconnect_physical_link
    3 [+1]  Flag  create_logical_link
    4 [+1]  Flag  accept_logical_link
    5 [+1]  Flag  disconnect_logical_link
    6 [+1]  Flag  logical_link_cancel
    7 [+1]  Flag  flow_spec_modify

  if octet == 22:
    0 [+1]  Flag  read_logical_link_accept_timeout
    1 [+1]  Flag  write_logical_link_accept_timeout
    2 [+1]  Flag  set_event_mask_page_2
    3 [+1]  Flag  read_location_data
    4 [+1]  Flag  write_location_data
    5 [+1]  Flag  read_local_amp_info
    6 [+1]  Flag  read_local_ampassoc
    7 [+1]  Flag  write_remote_ampassoc

  if octet == 23:
    0 [+1]  Flag  read_flow_control_mode
    1 [+1]  Flag  write_flow_control_mode
    2 [+1]  Flag  read_data_block_size

  if octet == 24:
    0 [+1]  Flag  read_enhanced_transmit_power_level
    2 [+1]  Flag  read_best_effort_flush_timeout
    3 [+1]  Flag  write_best_effort_flush_timeout
    4 [+1]  Flag  short_range_mode
    5 [+1]  Flag  read_le_host_supported
    6 [+1]  Flag  write_le_host_support

  if octet == 25:
    0 [+1]  Flag  le_set_event_mask
    1 [+1]  Flag  le_read_buffer_size_v1
    2 [+1]  Flag  le_read_local_supported_features
    4 [+1]  Flag  le_set_random_address
    5 [+1]  Flag  le_set_advertising_parameters
    6 [+1]  Flag  le_read_advertising_channel_tx_power
    7 [+1]  Flag  le_set_advertising_data

  if octet == 26:
    0 [+1]  Flag  le_set_scan_response_data
    1 [+1]  Flag  le_set_advertising_enable
    2 [+1]  Flag  le_set_scan_parameters
    3 [+1]  Flag  le_set_scan_enable
    4 [+1]  Flag  le_create_connection
    5 [+1]  Flag  le_create_connection_cancel
    6 [+1]  Flag  le_read_filter_accept_list_size
    7 [+1]  Flag  le_clear_filter_accept_list

  if octet == 27:
    0 [+1]  Flag  le_add_device_to_filter_accept_list
    1 [+1]  Flag  le_remove_device_from_filter_accept_list
    2 [+1]  Flag  le_connection_update
    3 [+1]  Flag  le_set_host_channel_classification
    4 [+1]  Flag  le_read_channel_map
    5 [+1]  Flag  le_read_remote_features
    6 [+1]  Flag  le_encrypt
    7 [+1]  Flag  le_rand

  if octet == 28:
    0 [+1]  Flag  le_start_encryption
    1 [+1]  Flag  le_long_term_key_request_reply
    2 [+1]  Flag  le_long_term_key_request_negative_reply
    3 [+1]  Flag  le_read_supported_states
    4 [+1]  Flag  le_receiver_test_v1
    5 [+1]  Flag  le_transmitter_test_v1
    6 [+1]  Flag  le_test_end

  if octet == 29:
    3 [+1]  Flag  enhanced_setup_synchronous_connection
    4 [+1]  Flag  enhanced_accept_synchronous_connection
    5 [+1]  Flag  read_local_supported_codecs
    6 [+1]  Flag  set_mws_channel_parameters
    7 [+1]  Flag  set_external_frame_configuration

  if octet == 30:
    0 [+1]  Flag  set_mws_signaling
    1 [+1]  Flag  set_mws_transport_layer
    2 [+1]  Flag  set_mws_scan_frequency_table
    3 [+1]  Flag  get_mws_transport_layer_configuration
    4 [+1]  Flag  set_mws_pattern_configuration
    5 [+1]  Flag  set_triggered_clock_capture
    6 [+1]  Flag  truncated_page
    7 [+1]  Flag  truncated_page_cancel

  if octet == 31:
    0 [+1]  Flag  set_connectionless_peripheral_broadcast
    1 [+1]  Flag  set_connectionless_peripheral_broadcast_receive
    2 [+1]  Flag  start_synchronization_train
    3 [+1]  Flag  receive_synchronization_train
    4 [+1]  Flag  set_reserved_ltaddr
    5 [+1]  Flag  delete_reserved_ltaddr
    6 [+1]  Flag  set_connectionless_peripheral_broadcast_data
    7 [+1]  Flag  read_synchronization_train_parameters

  if octet == 32:
    0 [+1]  Flag  write_synchronization_train_parameters
    1 [+1]  Flag  remote_oob_extended_data_request_reply
    2 [+1]  Flag  read_secure_connections_host_support
    3 [+1]  Flag  write_secure_connections_host_support
    4 [+1]  Flag  read_authenticated_payload_timeout
    5 [+1]  Flag  write_authenticated_payload_timeout
    6 [+1]  Flag  read_local_oob_extended_data
    7 [+1]  Flag  write_secure_connections_test_mode

  if octet == 33:
    0 [+1]  Flag  read_extended_page_timeout
    1 [+1]  Flag  write_extended_page_timeout
    2 [+1]  Flag  read_extended_inquiry_length
    3 [+1]  Flag  write_extended_inquiry_length
    4 [+1]  Flag  le_remote_connection_parameter_request_reply
    5 [+1]  Flag  le_remote_connection_parameter_request_negative_reply
    6 [+1]  Flag  le_set_data_length
    7 [+1]  Flag  le_read_suggested_default_data_length

  if octet == 34:
    0 [+1]  Flag  le_write_suggested_default_data_length
    1 [+1]  Flag  le_read_local_p256_public_key
    2 [+1]  Flag  le_generate_dh_key_v1
    3 [+1]  Flag  le_add_device_to_resolving_list
    4 [+1]  Flag  le_remove_device_from_resolving_list
    5 [+1]  Flag  le_clear_resolving_list
    6 [+1]  Flag  le_read_resolving_list_size
    7 [+1]  Flag  le_read_peer_resolvable_address

  if octet == 35:
    0 [+1]  Flag  le_read_local_resolvable_address
    1 [+1]  Flag  le_set_address_resolution_enable
    2 [+1]  Flag  le_set_resolvable_private_address_timeout
    3 [+1]  Flag  le_read_maximum_data_length
    4 [+1]  Flag  le_read_phy
    5 [+1]  Flag  le_set_default_phy
    6 [+1]  Flag  le_set_phy
    7 [+1]  Flag  le_enhanced_receiver_test_v2

  if octet == 36:
    0 [+1]  Flag  le_enhanced_transmitter_test_v2
    1 [+1]  Flag  le_set_advertising_set_random_address
    2 [+1]  Flag  le_set_extended_advertising_parameters
    3 [+1]  Flag  le_set_extended_advertising_data
    4 [+1]  Flag  le_set_extended_scan_response_data
    5 [+1]  Flag  le_set_extended_advertising_enable
    6 [+1]  Flag  le_read_maximum_advertising_data_length
    7 [+1]  Flag  le_read_number_of_supported_advertising_sets

  if octet == 37:
    0 [+1]  Flag  le_remove_advertising_set
    1 [+1]  Flag  le_clear_advertising_sets
    2 [+1]  Flag  le_set_periodic_advertising_parameters
    3 [+1]  Flag  le_set_periodic_advertising_data
    4 [+1]  Flag  le_set_periodic_advertising_enable
    5 [+1]  Flag  le_set_extended_scan_parameters
    6 [+1]  Flag  le_set_extended_scan_enable
    7 [+1]  Flag  le_extended_create_connection

  if octet == 38:
    0 [+1]  Flag  le_periodic_advertising_create_sync
    1 [+1]  Flag  le_periodic_advertising_create_sync_cancel
    2 [+1]  Flag  le_periodic_advertising_terminate_sync
    3 [+1]  Flag  le_add_device_to_periodic_advertiser_list
    4 [+1]  Flag  le_remove_device_from_periodic_advertiser_list
    5 [+1]  Flag  le_clear_periodic_advertiser_list
    6 [+1]  Flag  le_read_periodic_advertiser_list_size
    7 [+1]  Flag  le_read_transmit_power

  if octet == 39:
    0 [+1]  Flag  le_read_rf_path_compensation
    1 [+1]  Flag  le_write_rf_path_compensation
    2 [+1]  Flag  le_set_privacy_mode
    3 [+1]  Flag  le_receiver_test_v3
    4 [+1]  Flag  le_transmitter_test_v3
    5 [+1]  Flag  le_set_connectionless_cte_transmit_parameters
    6 [+1]  Flag  le_set_connectionless_cte_transmit_enable
    7 [+1]  Flag  le_set_connectionless_iq_sampling_enable

  if octet == 40:
    0 [+1]  Flag  le_set_connection_cte_receive_parameters
    1 [+1]  Flag  le_set_connection_cte_transmit_parameters
    2 [+1]  Flag  le_connection_cte_request_enable
    3 [+1]  Flag  le_connection_cte_response_enable
    4 [+1]  Flag  le_read_antenna_information
    5 [+1]  Flag  le_set_periodic_advertising_receive_enable
    6 [+1]  Flag  le_periodic_advertising_sync_transfer
    7 [+1]  Flag  le_periodic_advertising_set_info_transfer

  if octet == 41:
    0 [+1]  Flag  le_set_periodic_advertising_sync_transfer_parameters
    1 [+1]  Flag  le_set_default_periodic_advertising_sync_transfer_parameters
    2 [+1]  Flag  le_generate_dh_key_v3
    3 [+1]  Flag  read_local_simple_pairing_options
    4 [+1]  Flag  le_modify_sleep_clock_accuracy
    5 [+1]  Flag  le_read_buffer_size_v2
    6 [+1]  Flag  le_read_isotx_sync
    7 [+1]  Flag  le_set_cig_parameters

  if octet == 42:
    0 [+1]  Flag  le_set_cig_parameters_test
    1 [+1]  Flag  le_create_cis
    2 [+1]  Flag  le_remove_cig
    3 [+1]  Flag  le_accept_cis_request
    4 [+1]  Flag  le_reject_cis_request
    5 [+1]  Flag  le_create_big
    6 [+1]  Flag  le_create_big_test
    7 [+1]  Flag  le_terminate_big

  if octet == 43:
    0 [+1]  Flag  le_big_create_sync
    1 [+1]  Flag  le_big_terminate_sync
    2 [+1]  Flag  le_request_peer_sca
    3 [+1]  Flag  le_setup_iso_data_path
    4 [+1]  Flag  le_remove_iso_data_path
    5 [+1]  Flag  le_iso_transmit_test
    6 [+1]  Flag  le_iso_receive_test
    7 [+1]  Flag  le_iso_read_test_counters

  if octet == 44:
    0 [+1]  Flag  le_iso_test_end
    1 [+1]  Flag  le_set_host_feature
    2 [+1]  Flag  le_read_iso_link_quality
    3 [+1]  Flag  le_enhanced_read_transmit_power_level
    4 [+1]  Flag  le_read_remote_transmit_power_level
    5 [+1]  Flag  le_set_path_loss_reporting_parameters
    6 [+1]  Flag  le_set_path_loss_reporting_enable
    7 [+1]  Flag  le_set_transmit_power_reporting_enable

  if octet == 45:
    0 [+1]  Flag  le_transmitter_test_v4
    1 [+1]  Flag  set_ecosystem_base_interval
    2 [+1]  Flag  read_local_supported_codecs_v2
    3 [+1]  Flag  read_local_supported_codec_capabilities
    4 [+1]  Flag  read_local_supported_controller_delay
    5 [+1]  Flag  configure_data_path

  if octet == 46:
    0 [+1]  Flag  le_set_default_subrate
    1 [+1]  Flag  le_subrate_request
    2 [+1]  Flag  le_set_extended_advertising_parameters_v2
    5 [+1]  Flag  le_set_periodic_advertising_subevent_data
    6 [+1]  Flag  le_set_periodic_advertising_response_data
    7 [+1]  Flag  le_set_periodic_sync_subevent

  if octet == 47:
    0 [+1]  Flag  le_extended_create_connection_v2
    1 [+1]  Flag  le_set_periodic_advertising_parameters_v2


enum LEChannelSelectionAlgorithm:
  [maximum_bits: 8]
  ALGORITHM1 = 0x00
  ALGORITHM2 = 0x01

# ========================= HCI Event packets ===========================
# Core Spec v5.3 Vol 4, Part E, Section 7.7


struct InquiryCompleteEvent:
  -- 7.7.1 Inquiry Complete event (v1.1) (BR/EDR)
  -- HCI_Inquiry_Complete
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]  hci.EventHeader  header
  $next [+1]         hci.StatusCode   status


struct InquiryResult:
  0     [+hci.BdAddr.$size_in_bytes]  hci.BdAddr                  bd_addr
    -- BD_ADDR for a device which responded.

  $next [+1]                          hci.PageScanRepetitionMode  page_scan_repetition_mode
  $next [+2]                          UInt                        reserved
    -- Reserved for future use.

  $next [+3]                          hci.ClassOfDevice           class_of_device
    -- Class of Device for the device.

  $next [+2]                          hci.ClockOffset             clock_offset
    -- The lower 15 bits represent bits 16-2 of CLKNPeripheral-CLK.


struct InquiryResultEvent:
  -- 7.7.2 Inquiry Result event (v1.1) (BR/EDR)
  -- HCI_Inquiry_Result
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]                     hci.EventHeader  header
  $next [+1]                            UInt             num_responses
    -- Number of responses from the Inquiry.

  let response_size = InquiryResult.$size_in_bytes
  $next [+num_responses*response_size]  InquiryResult[]  responses


struct ConnectionCompleteEvent:
  -- 7.7.3 Connection Complete Event (v1.1) (BR/EDR)
  -- HCI_Connection_Complete
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]                   hci.EventHeader         header
  $next [+1]                          hci.StatusCode          status
  $next [+2]                          UInt                    connection_handle
    [requires: 0x0000 <= this <= 0x0EFF]

  $next [+hci.BdAddr.$size_in_bytes]  hci.BdAddr              bd_addr
    -- The address of the connected device

  $next [+1]                          LinkType                link_type
  $next [+1]                          hci.GenericEnableParam  encryption_enabled


struct ConnectionRequestEvent:
  -- 7.7.4 Connection Request event (v1.1) (BR/EDR)
  -- HCI_Connection_Request
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]                   hci.EventHeader    header
  $next [+hci.BdAddr.$size_in_bytes]  hci.BdAddr         bd_addr
    -- The address of the device that's requesting the connection.

  $next [+3]                          hci.ClassOfDevice  class_of_device
    -- The Class of Device of the device which requests the connection.

  $next [+1]                          LinkType           link_type


struct DisconnectionCompleteEvent:
  -- 7.7.5 Disconnection Complete event (v1.1) (BR/EDR & LE)
  -- HCI_Disconnection_Complete
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]  hci.EventHeader  header
  $next [+1]         hci.StatusCode   status
  $next [+2]         UInt             connection_handle
    [requires: 0x0000 <= this <= 0x0EFF]

  $next [+1]         hci.StatusCode   reason


struct AuthenticationCompleteEvent:
  -- 7.7.6 Authentication Complete event (v1.1) (BR/EDR)
  -- HCI_Authentication_Complete
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]  hci.EventHeader  header
  $next [+1]         hci.StatusCode   status
  $next [+2]         UInt             connection_handle
    [requires: 0x0000 <= this <= 0x0EFF]


struct RemoteNameRequestCompleteEvent:
  -- 7.7.7 Remote Name Request Complete event (v1.1) (BR/EDR)
  -- HCI_Remote_Name_Request_Complete
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]                   hci.EventHeader  header
  $next [+1]                          hci.StatusCode   status
  $next [+hci.BdAddr.$size_in_bytes]  hci.BdAddr       bd_addr
  $next [+248]                        UInt:8[248]      remote_name
    -- UTF-8 encoded friendly name. If the name is less than 248 characters, it
    -- is null terminated and the remaining bytes are not valid.


struct EncryptionChangeEventV1:
  -- 7.7.8 Encryption Change event (v1.1) (BR/EDR & LE)
  -- HCI_Encryption_Change [v1]
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]  hci.EventHeader   header
  $next [+1]         hci.StatusCode    status
  $next [+2]         UInt              connection_handle
    [requires: 0x0000 <= this <= 0x0EFF]

  $next [+1]         EncryptionStatus  encryption_enabled


struct ChangeConnectionLinkKeyCompleteEvent:
  -- 7.7.9 Change Connection Link Key Complete event (v1.1) (BR/EDR)
  -- HCI_Change_Connection_Link_Key_Complete
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]  hci.EventHeader  header
  $next [+1]         hci.StatusCode   status
  $next [+2]         UInt             connection_handle
    [requires: 0x0000 <= this <= 0x0EFF]

# 7.7.10 Link Key Type Changed event
# HCI_Link_Key_Type_Changed
# TODO: b/265052417 - Definition needs to be added


struct ReadRemoteSupportedFeaturesCompleteEvent:
  -- 7.7.11 Read Remote Supported Features Complete event (v1.1) (BR/EDR)
  -- HCI_Read_Remote_Supported_Features_Complete
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]  hci.EventHeader  header
  $next [+1]         hci.StatusCode   status
  $next [+2]         UInt             connection_handle
    [requires: 0x0000 <= this <= 0x0EFF]

  $next [+8]         LmpFeatures(0)   lmp_features
    -- Page 0 of the LMP features.


struct ReadRemoteVersionInfoCompleteEvent:
  -- 7.7.12 Read Remote Version Information Complete event (v1.1) (BR/EDR & LE)
  -- HCI_Read_Remote_Version_Information_Complete
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]  hci.EventHeader           header
  $next [+1]         hci.StatusCode            status
  $next [+2]         UInt                      connection_handle
    [requires: 0x0000 <= this <= 0x0EFF]

  $next [+1]         CoreSpecificationVersion  version
    -- Version of the Current LMP or Link Layer supported by the remote Controller.

  $next [+2]         UInt                      company_identifier
    -- Company identifier for the manufacturer of the remote Controller. Assigned by Bluetooth SIG.

  $next [+2]         UInt                      subversion
    -- Revision of the LMP or Link Layer implementation in the remote Controller. This value is vendor-specific.

# 7.7.13 QoS Setup Complete event
# HCI_QoS_Setup_Complete
# TODO: b/265052417 - Definition needs to be added


struct SimpleCommandCompleteEvent:
  -- 7.7.14 Command Complete event (status only)
  -- HCI_Command_Complete
  -- A Command Complete event where a StatusCode is the only return parameter.
  -- Also useful for generically getting the status of a larger command complete
  -- event.
  let hdr_size = hci.CommandCompleteEvent.$size_in_bytes
  0     [+hdr_size]  hci.CommandCompleteEvent  command_complete
  $next [+1]         hci.StatusCode            status


struct ReadLocalVersionInfoCommandCompleteEvent:
  -- 7.7.14 Command Complete event (7.4.1 Read Local Version Information command)

  let hdr_size = hci.CommandCompleteEvent.$size_in_bytes

  0     [+hdr_size]  hci.CommandCompleteEvent  command_complete

  $next [+1]         hci.StatusCode            status

  $next [+1]         CoreSpecificationVersion  hci_version
    -- Version of the HCI Specification supported by the Controller. See
    -- Assigned Numbers

  $next [+2]         UInt                      hci_subversion
    -- Revision of the HCI implementation in the Controller. This value is
    -- vendor-specific.

  $next [+1]         UInt                      lmp_version
    -- Version of the Current LMP supported by the Controller. See Assigned
    -- Numbers

  $next [+2]         UInt                      company_identifier
    -- Company identifier for the manufacturer of the Controller. See Assigned
    -- Numbers

  $next [+2]         UInt                      lmp_subversion
    -- Subversion of the Current LMP in the Controller. This value is
    -- vendor-specific.


struct ReadLocalSupportedCommandsCommandCompleteEvent:
  -- 7.7.14 Command Complete event (7.4.2 Read Local Supported Commands command)
  let hdr_size = hci.CommandCompleteEvent.$size_in_bytes
  0     [+hdr_size]  hci.CommandCompleteEvent  command_complete
  $next [+1]         hci.StatusCode            status
  $next [+1]         SupportedCommands(0)      supported_commands_0
  $next [+1]         SupportedCommands(1)      supported_commands_1
  $next [+1]         SupportedCommands(2)      supported_commands_2
  $next [+1]         SupportedCommands(3)      supported_commands_3
  $next [+1]         SupportedCommands(4)      supported_commands_4
  $next [+1]         SupportedCommands(5)      supported_commands_5
  $next [+1]         SupportedCommands(6)      supported_commands_6
  $next [+1]         SupportedCommands(7)      supported_commands_7
  $next [+1]         SupportedCommands(8)      supported_commands_8
  $next [+1]         SupportedCommands(9)      supported_commands_9
  $next [+1]         SupportedCommands(10)     supported_commands_10
  $next [+1]         SupportedCommands(11)     supported_commands_11
  $next [+1]         SupportedCommands(12)     supported_commands_12
  $next [+1]         SupportedCommands(13)     supported_commands_13
  $next [+1]         SupportedCommands(14)     supported_commands_14
  $next [+1]         SupportedCommands(15)     supported_commands_15
  $next [+1]         SupportedCommands(16)     supported_commands_16
  $next [+1]         SupportedCommands(17)     supported_commands_17
  $next [+1]         SupportedCommands(18)     supported_commands_18
  $next [+1]         SupportedCommands(19)     supported_commands_19
  $next [+1]         SupportedCommands(20)     supported_commands_20
  $next [+1]         SupportedCommands(21)     supported_commands_21
  $next [+1]         SupportedCommands(22)     supported_commands_22
  $next [+1]         SupportedCommands(23)     supported_commands_23
  $next [+1]         SupportedCommands(24)     supported_commands_24
  $next [+1]         SupportedCommands(25)     supported_commands_25
  $next [+1]         SupportedCommands(26)     supported_commands_26
  $next [+1]         SupportedCommands(27)     supported_commands_27
  $next [+1]         SupportedCommands(28)     supported_commands_28
  $next [+1]         SupportedCommands(29)     supported_commands_29
  $next [+1]         SupportedCommands(30)     supported_commands_30
  $next [+1]         SupportedCommands(31)     supported_commands_31
  $next [+1]         SupportedCommands(32)     supported_commands_32
  $next [+1]         SupportedCommands(33)     supported_commands_33
  $next [+1]         SupportedCommands(34)     supported_commands_34
  $next [+1]         SupportedCommands(35)     supported_commands_35
  $next [+1]         SupportedCommands(36)     supported_commands_36
  $next [+1]         SupportedCommands(37)     supported_commands_37
  $next [+1]         SupportedCommands(38)     supported_commands_38
  $next [+1]         SupportedCommands(39)     supported_commands_39
  $next [+1]         SupportedCommands(40)     supported_commands_40
  $next [+1]         SupportedCommands(41)     supported_commands_41
  $next [+1]         SupportedCommands(42)     supported_commands_42
  $next [+1]         SupportedCommands(43)     supported_commands_43
  $next [+1]         SupportedCommands(44)     supported_commands_44
  $next [+1]         SupportedCommands(45)     supported_commands_45
  $next [+1]         SupportedCommands(46)     supported_commands_46
  $next [+1]         SupportedCommands(47)     supported_commands_47


struct ReadBufferSizeCommandCompleteEvent:
  -- 7.7.14 Command Complete event (7.4.5 Read Buffer Size command)

  let hdr_size = hci.CommandCompleteEvent.$size_in_bytes

  0     [+hdr_size]  hci.CommandCompleteEvent  command_complete

  $next [+1]         hci.StatusCode            status

  $next [+2]         UInt                      acl_data_packet_length
    -- Maximum length (in octets) of the data portion of each HCI ACL Data
    -- packet that the Controller is able to accept.
    [requires: 0x0001 <= this <= 0xFFFF]

  $next [+1]         UInt                      synchronous_data_packet_length
    -- Maximum length (in octets) of the data portion of each HCI Synchronous
    -- Data packet that the Controller is able to accept.
    [requires: 0x01 <= this <= 0xFF]

  $next [+2]         UInt                      total_num_acl_data_packets
    -- Total number of HCI ACL Data packets that can be stored in the data
    -- buffers of the Controller.
    [requires: 0x0001 <= this <= 0xFFFF]

  $next [+2]         UInt                      total_num_synchronous_data_packets
    -- Total number of HCI Synchronous Data packets that can be stored in the
    -- data buffers of the Controller. A value of 0 indicates that the
    -- Controller does not support SCO or eSCO over HCI.


struct ReadBdAddrCommandCompleteEvent:
  -- 7.7.14 Command Complete event (7.4.6 Read BD_ADDR command)
  let hdr_size = hci.CommandCompleteEvent.$size_in_bytes
  0     [+hdr_size]                   hci.CommandCompleteEvent  command_complete
  $next [+1]                          hci.StatusCode            status
  $next [+hci.BdAddr.$size_in_bytes]  hci.BdAddr                bd_addr


struct ReadLocalSupportedControllerDelayCommandCompleteEvent:
  -- 7.7.14 Command Complete event (7.4.11 Read Local Supported Controller Delay command)
  let hdr_size = hci.CommandCompleteEvent.$size_in_bytes
  0     [+hdr_size]  hci.CommandCompleteEvent  command_complete
  $next [+1]         hci.StatusCode            status
  $next [+3]         UInt                      min_controller_delay
  $next [+3]         UInt                      max_controller_delay


struct LEReadBufferSizeV2CommandCompleteEvent:
  -- 7.7.14 Command Complete event (7.8.2 LE Read Buffer Size [v2] command)

  let hdr_size = hci.CommandCompleteEvent.$size_in_bytes

  0     [+hdr_size]  hci.CommandCompleteEvent  command_complete

  $next [+1]         hci.StatusCode            status

  $next [+2]         UInt                      le_acl_data_packet_length
    -- Maximum length (in octets) of the data portion of each HCI ACL data packet,
    -- or 0 if no dedicated LE buffer exists.
    [requires: 0x001b <= this <= 0xFFFF || this == 0x0000]

  $next [+1]         UInt                      total_num_le_acl_data_packets
    -- The total number of HCI ACL data packets that can be stored in the data
    -- buffers of the Controller, or 0 if no dedicated LE buffer exists.

  $next [+2]         UInt                      iso_data_packet_length
    -- The maximum length (in octets) of the data portion of each HCI ISO data
    -- packet, or 0 if no dedicated ISO buffer exists.

  $next [+1]         UInt                      total_num_iso_data_packets
    -- The total number of HCI ISO data packets that can be stored in the ISO
    -- buffers of the controller, or 0 if no dedicated ISO buffer exists.


struct LEReadLocalSupportedFeaturesCommandCompleteEvent:
  -- 7.7.14 Command Complete event (7.8.3 LE Read Local Supported Features command)
  let hdr_size = hci.CommandCompleteEvent.$size_in_bytes
  0     [+hdr_size]                      hci.CommandCompleteEvent  command_complete
  $next [+1]                             hci.StatusCode            status
  $next [+8]  bits:
    0     [+LEFeatureSet.$size_in_bits]  LEFeatureSet              le_features


struct LESetupISODataPathCommandCompleteEvent:
  -- 7.7.14 Command Complete event (7.8.109 LE Setup ISO Data Path command)
  let hdr_size = hci.CommandCompleteEvent.$size_in_bytes
  0     [+hdr_size]  hci.CommandCompleteEvent  command_complete
  $next [+1]         hci.StatusCode            status
  $next [+2]         UInt                      connection_handle


struct CommandStatusEvent:
  -- 7.7.15 Command Status event
  -- HCI_Command_Status
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]  hci.EventHeader  header
  $next [+1]         hci.StatusCode   status
  $next [+1]         UInt             num_hci_command_packets
  $next [+2]         hci.OpCodeBits   command_opcode

# 7.7.16 Hardware Error event
# HCI_Hardware_Error
# TODO: b/265052417 - Definition needs to be added


# 7.7.17 Flush Occurred event
# HCI_Flush_Occurred
# TODO: b/265052417 - Definition needs to be added


struct RoleChangeEvent:
  -- 7.7.18 Role Change event (BR/EDR) (v1.1)
  -- HCI_Role_Change
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]                   hci.EventHeader     header
  $next [+1]                          hci.StatusCode      status
  $next [+hci.BdAddr.$size_in_bytes]  hci.BdAddr          bd_addr
    -- The address of the device for which a role change has completed.

  $next [+1]                          hci.ConnectionRole  role
    -- The new role for the specified address.

# 7.7.19 Number Of Completed Packets event
# HCI_Number_Of_Completed_Packets
# TODO: b/265052417 - Definition needs to be added


# 7.7.20 Mode Change event
# HCI_Mode_Change
# TODO: b/265052417 - Definition needs to be added


# 7.7.21 Return Link Keys event
# HCI_Return_Link_Keys
# TODO: b/265052417 - Definition needs to be added


# 7.7.22 PIN Code Request event
# HCI_PIN_Code_Request
# TODO: b/265052417 - Definition needs to be added


struct LinkKeyRequestEvent:
  -- 7.7.23 Link Key Request event (v1.1) (BR/EDR)
  -- HCI_Link_Key_Request
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]                   hci.EventHeader  header
  $next [+hci.BdAddr.$size_in_bytes]  hci.BdAddr       bd_addr
    -- The address for the device that a host-stored link key is being requested.


struct LinkKeyNotificationEvent:
  -- 7.7.24 Link Key Notification event (v1.1) (BR/EDR)
  -- HCI_Link_Key_Notification
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]                    hci.EventHeader  header
  $next [+hci.BdAddr.$size_in_bytes]   hci.BdAddr       bd_addr
    -- The address for the device for which a new link key has been generated.

  $next [+hci.LinkKey.$size_in_bytes]  hci.LinkKey      link_key
    -- Link key for the associated address.

  $next [+1]                           KeyType          key_type
    -- Type of key used when pairing.

# 7.7.25 Loopback Command event
# HCI_Loopback_Command
# TODO: b/265052417 - Definition needs to be added


struct DataBufferOverflowEvent:
  -- 7.7.26 Data Buffer Overflow event (v1.1) (BR/EDR & LE)
  -- HCI_Data_Buffer_Overflow
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]  hci.EventHeader  header
  $next [+1]         LinkType         ll_type

# 7.7.27 Max Slots Change event
# HCI_Max_Slots_Change
# TODO: b/265052417 - Definition needs to be added


# 7.7.28 Read Clock Offset Complete event
# HCI_Read_Clock_Offset_Complete
# TODO: b/265052417 - Definition needs to be added


# 7.7.29 Connection Packet Type Changed event
# HCI_Connection_Packet_Type_Changed
# TODO: b/265052417 - Definition needs to be added


# 7.7.30 QoS Violation event
# HCI_QoS_Violation
# TODO: b/265052417 - Definition needs to be added


# 7.7.31 Page Scan Repetition Mode Change event
# HCI_Page_Scan_Repetition_Mode_Change
# TODO: b/265052417 - Definition needs to be added


# 7.7.32 Flow Specification Complete event
# HCI_Flow_Specification_Complete
# TODO: b/265052417 - Definition needs to be added


struct InquiryResultWithRssi:
  -- A single inquiry result (with RSSI).
  0     [+hci.BdAddr.$size_in_bytes]  hci.BdAddr                  bd_addr
    -- The address for the device which responded.

  $next [+1]                          hci.PageScanRepetitionMode  page_scan_repetition_mode
    -- The Page Scan Repetition Mode being used by the remote device.

  $next [+1]                          UInt                        reserved
  $next [+3]                          hci.ClassOfDevice           class_of_device
  $next [+2]                          hci.ClockOffset             clock_offset
    -- The lower 15 bits represent bits 16-2 of CLKNPeripheral-CLK. The most
    -- significant bit is reserved.

  $next [+1]                          Int                         rssi
    -- Units: dBm
    [requires: -127 <= this <= 20]


struct InquiryResultWithRssiEvent:
  -- 7.7.33 Inquiry Result with RSSI event (v1.2) (BR/EDR)
  -- HCI_Inquiry_Result_with_RSSI
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]                     hci.EventHeader          header
  $next [+1]                            UInt                     num_responses
    -- The number of responses included.

  let response_size = InquiryResultWithRssi.$size_in_bytes
  $next [+num_responses*response_size]  InquiryResultWithRssi[]  responses


struct ReadRemoteExtendedFeaturesCompleteEvent:
  -- 7.7.34 Read Remote Extended Features Complete event (v1.1) (BR/EDR)
  -- HCI_Read_Remote_Extended_Features_Complete
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]  hci.EventHeader           header
  $next [+1]         hci.StatusCode            status
  $next [+2]         UInt                      connection_handle
    -- Only the lower 12-bits are meaningful.
    [requires: 0x0000 <= this <= 0x0EFF]

  $next [+1]         UInt                      page_number
    -- 0x00: The normal LMP features as returned by HCI_Read_Remote_Supported_Features command.
    -- 0x01 to 0xFF: The page number of the features returned.

  $next [+1]         UInt                      max_page_number
    -- The highest features page number which contains non-zero bits for the remote device.

  $next [+8]         LmpFeatures(page_number)  lmp_features
    -- Bit map of requested page of LMP features.


struct SynchronousConnectionCompleteEvent:
  -- 7.7.35 Synchronous Connection Complete event (BR/EDR)
  -- HCI_Synchronous_Connection_Complete

  let hdr_size = hci.EventHeader.$size_in_bytes

  0     [+hdr_size]                   hci.EventHeader   header

  $next [+1]                          hci.StatusCode    status

  $next [+2]                          UInt              connection_handle
    -- A connection handle for the newly created SCO connection.
    [requires: 0x0000 <= this <= 0x0EFF]

  $next [+hci.BdAddr.$size_in_bytes]  hci.BdAddr        bd_addr
    -- BD_ADDR of the other connected device forming the connection.

  $next [+1]                          LinkType          link_type

  $next [+1]                          UInt              transmission_interval
    -- Time between two consecutive eSCO instants measured in slots. Shall be
    -- zero for SCO links.

  $next [+1]                          UInt              retransmission_window
    -- The size of the retransmission window measured in slots. Shall be zero
    -- for SCO links.

  $next [+2]                          UInt              rx_packet_length
    -- Length in bytes of the eSCO payload in the receive direction. Shall be
    -- zero for SCO links.

  $next [+2]                          UInt              tx_packet_length
    -- Length in bytes of the eSCO payload in the transmit direction. Shall be
    -- zero for SCO links.

  $next [+1]                          hci.CodingFormat  air_mode

# 7.7.36 Synchronous Connection Changed event
# HCI_Synchronous_Connection_Changed
# TODO: b/265052417 - Definition needs to be added


# 7.7.37 Sniff Subrating event
# HCI_Sniff_Subrating
# TODO: b/265052417 - Definition needs to be added


struct ExtendedInquiryResultEvent:
  -- 7.7.38 Extended Inquiry Result event (v1.2) (BR/EDR)
  -- HCI_Extended_Inquiry_Result
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]                   hci.EventHeader             header
  $next [+1]                          UInt                        num_responses
    -- Number of responses from the inquiry. The HCI_Extended_Inquiry_Result
    -- event always contains a single response.
    [requires: this == 0x01]

  $next [+hci.BdAddr.$size_in_bytes]  hci.BdAddr                  bd_addr
    -- BD_ADDR of the device that responded.

  $next [+1]                          hci.PageScanRepetitionMode  page_scan_repetition_mode
    -- The Page Scan Repetition Mode being used by the remote device.

  $next [+1]                          UInt                        reserved
  $next [+3]                          hci.ClassOfDevice           class_of_device
  $next [+2]                          hci.ClockOffset             clock_offset
    -- The lower 15 bits represent bits 16-2 of CLKNPeripheral-CLK.

  $next [+1]                          Int                         rssi
    -- Units: dBm
    [requires: -127 <= this <= 20]

  $next [+240]                        UInt:8[240]                 extended_inquiry_response
    -- Extended inquiey response data as defined in Vol 3, Part C, Sec 8


struct EncryptionKeyRefreshCompleteEvent:
  -- 7.7.39 Encryption Key Refresh Complete event (v2.1 + EDR) (BR/EDR & LE)
  -- HCI_Encryption_Key_Refresh_Complete
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]  hci.EventHeader  header
  $next [+1]         hci.StatusCode   status
  $next [+2]         UInt             connection_handle
    -- The connection_handle on which the encryption key was refreshed due to
    -- encryption being started or resumed.
    [requires: 0x0000 <= this <= 0x0EFF]


struct IoCapabilityRequestEvent:
  -- 7.7.40 IO Capability Request event (v2.1 + EDR) (BR/EDR)
  -- HCI_IO_Capability_Request
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]                   hci.EventHeader  header
  $next [+hci.BdAddr.$size_in_bytes]  hci.BdAddr       bd_addr
    -- The address of the remote device involved in the Secure Simple Pairing
    -- process.


struct IoCapabilityResponseEvent:
  -- 7.7.41 IO Capability Response event (v2.1 + EDR) (BR/EDR)
  -- HCI_IO_Capability_Response
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]                   hci.EventHeader                 header
  $next [+hci.BdAddr.$size_in_bytes]  hci.BdAddr                      bd_addr
    -- The address of the remote device which the IO capabilities apply

  $next [+1]                          hci.IoCapability                io_capability
    -- IO Capabilities of the device

  $next [+1]                          hci.GenericPresenceParam        oob_data_present
    -- Whether out-of-band authentication data is present.

  $next [+1]                          hci.AuthenticationRequirements  authentication_requirements


struct UserConfirmationRequestEvent:
  -- 7.7.42 User Confirmation Request event (v2.1 + EDR) (BR/EDR)
  -- HCI_User_Confirmation_Request
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]                   hci.EventHeader  header
  $next [+hci.BdAddr.$size_in_bytes]  hci.BdAddr       bd_addr
    -- Address of the device involved in simple pairing process

  $next [+4]                          UInt             numeric_value
    -- Numeric value to be displayed.
    [requires: 0 <= this <= 999999]


struct UserPasskeyRequestEvent:
  -- 7.7.43 User Passkey Request event (v2.1 + EDR) (BR/EDR)
  -- HCI_User_Passkey_Request
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]                   hci.EventHeader  header
  $next [+hci.BdAddr.$size_in_bytes]  hci.BdAddr       bd_addr
    -- Address of the device involved in simple pairing process

# 7.7.44 Remote OOB Data Request event
# HCI_Remote_OOB_Data_Request
# TODO: b/265052417 - Definition needs to be added


struct SimplePairingCompleteEvent:
  -- 7.7.45 Simple Pairing Complete event (v2.1 + EDR) (BR/EDR)
  -- HCI_Simple_Pairing_Complete
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]                   hci.EventHeader  header
  $next [+1]                          hci.StatusCode   status
  $next [+hci.BdAddr.$size_in_bytes]  hci.BdAddr       bd_addr
    -- Address of the device involved in simple pairing process

# 7.7.46 Link Supervision Timeout Changed event
# HCI_Link_Supervision_Timeout_Changed
# TODO: b/265052417 - Definition needs to be added


# 7.7.47 Enhanced Flush Complete event
# HCI_Enhanced_Flush_Complete
# TODO: b/265052417 - Definition needs to be added


struct UserPasskeyNotificationEvent:
  -- 7.7.48 User Passkey Notification event (v2.1 + EDR) (BR/EDR)
  -- HCI_User_Passkey_Notification
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]                   hci.EventHeader  header
  $next [+hci.BdAddr.$size_in_bytes]  hci.BdAddr       bd_addr
    -- Address of the device involved in simple pairing process

  $next [+4]                          UInt             passkey
    -- Numeric value (passkey) entered by user.
    [requires: 0 <= this <= 999999]

# 7.7.49 Keypress Notification event
# HCI_Keypress_Notification
# TODO: b/265052417 - Definition needs to be added


# 7.7.50 Remote Host Supported Features Notification event
# HCI_Remote_Host_Supported_Features_Notification
# TODO: b/265052417 - Definition needs to be added


# 7.7.59 Number Of Completed Data Blocks event
# HCI_Number_Of_Completed_Data_Blocks
# TODO: b/265052417 - Definition needs to be added


struct LEMetaEvent:
  -- 7.7.65 LE Meta event
  let hdr_size = hci.EventHeader.$size_in_bytes
  0     [+hdr_size]  hci.EventHeader  header
  $next [+1]         UInt             subevent_code
    -- The event code for the LE subevent.


struct LEConnectionCompleteSubevent:
  -- 7.7.65.1 LE Connection Complete event
  -- HCI_LE_Connection_Complete

  0     [+LEMetaEvent.$size_in_bytes]  LEMetaEvent            le_meta_event

  $next [+1]                           hci.StatusCode         status

  $next [+2]                           UInt                   connection_handle
    -- Only the lower 12-bits are meaningful.
    [requires: 0x0000 <= this <= 0x0EFF]

  $next [+1]                           hci.ConnectionRole     role

  $next [+1]                           hci.LEPeerAddressType  peer_address_type

  $next [+hci.BdAddr.$size_in_bytes]   hci.BdAddr             peer_address
    -- Public Device Address or Random Device Address of the peer device.

  $next [+2]                           UInt                   connection_interval
    -- Time: N * 1.25 ms
    -- Range: 7.5 ms to 4 s
    [requires: 0x0006 <= this <= 0x0C80]

  $next [+2]                           UInt                   peripheral_latency
    [requires: 0x0000 <= this <= 0x01F3]

  $next [+2]                           UInt                   supervision_timeout
    -- Time: N * 10 ms
    -- Range: 100 ms to 32 s
    [requires: 0x000A <= this <= 0x0C80]

  $next [+1]                           LEClockAccuracy        central_clock_accuracy
    -- Only valid for a peripheral. On a central, this parameter shall be set to 0x00.

# 7.7.65.2 LE Advertising Report event
# HCI_LE_Advertising_Report
# TODO: b/265052417 - Definition needs to be added


struct LEAdvertisingReportData:
  0     [+1]                          LEAdvertisingEventType  event_type
  $next [+1]                          hci.LEAddressType       address_type
  $next [+hci.BdAddr.$size_in_bytes]  hci.BdAddr              address
  $next [+1]                          UInt                    data_length
    -- Length of the |data| field for the device which responded.
    [requires: 0 <= this <= 0x1F]

  $next [+data_length]                UInt:8[data_length]     data
    -- |data_length| octets of advertising or scan response data formatted as defined in Core
    -- Spec [Vol 3] Part C, Section 11. Note: Each element of this array has a variable length.

  $next [+1]                          Int                     rssi
    -- Units: dBm. A value of 0x7F means RSSI is not available.
    [requires: -127 <= this <= 20 || this == 0x7F]


struct LEAdvertisingReportSubevent:
  0     [+LEMetaEvent.$size_in_bytes]  LEMetaEvent           le_meta_event
  $next [+1]                           UInt                  num_reports
    [requires: this <= 0x19]

  # The -1 at the end is sizeof(num_reports).
  let reports_size = le_meta_event.header.parameter_total_size-(LEMetaEvent.$size_in_bytes-hci.EventHeader.$size_in_bytes)-1
  $next [+reports_size]                UInt:8[reports_size]  reports
    -- Since each report has a variable length, they are stored in a UInt:8 array.


struct LEConnectionUpdateCompleteSubevent:
  -- 7.7.65.3 LE Connection Update Complete event
  -- HCI_LE_Connection_Update_Complete

  0     [+LEMetaEvent.$size_in_bytes]  LEMetaEvent     le_meta_event

  $next [+1]                           hci.StatusCode  status

  $next [+2]                           UInt            connection_handle
    -- Only the lower 12-bits are meaningful.
    [requires: 0x0000 <= this <= 0x0EFF]

  $next [+2]                           UInt            connection_interval
    -- Time: N * 1.25 ms
    -- Range: 7.5 ms to 4 s
    [requires: 0x0006 <= this <= 0x0C80]

  $next [+2]                           UInt            peripheral_latency
    [requires: 0x0000 <= this <= 0x01F3]

  $next [+2]                           UInt            supervision_timeout
    -- Time: N * 10 ms
    -- Range: 100 ms to 32 s
    [requires: 0x000A <= this <= 0x0C80]


struct LEReadRemoteFeaturesCompleteSubevent:
  -- 7.7.65.4 LE Read Remote Features Complete event
  -- HCI_LE_Read_Remote_Features_Complete
  0     [+LEMetaEvent.$size_in_bytes]    LEMetaEvent     le_meta_event
  $next [+1]                             hci.StatusCode  status
  $next [+2]                             UInt            connection_handle
    -- Only the lower 12-bits are meaningful.
    [requires: 0x0000 <= this <= 0x0EFF]

  $next [+8]  bits:
    0     [+LEFeatureSet.$size_in_bits]  LEFeatureSet    le_features


struct LELongTermKeyRequestSubevent:
  -- 7.7.65.5 LE Long Term Key Request event (v4.0) (LE)
  -- HCI_LE_Long_Term_Key_Request
  0     [+LEMetaEvent.$size_in_bytes]  LEMetaEvent  le_meta_event
  $next [+2]                           UInt         connection_handle
    [requires: 0x0000 <= this <= 0x0EFF]

  $next [+8]                           UInt         random_number
  $next [+2]                           UInt         encrypted_diversifier

# 7.7.65.6 LE Remote Connection Parameter Request event
# HCI_LE_Remote_Connection_Parameter_Request
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.7 LE Data Length Change event
# HCI_LE_Data_Length_Change
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.8 LE Read Local P-256 Public Key Complete event
# HCI_LE_Read_Local_P-256_Public_Key_Complete
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.9 LE Generate DHKey Complete event
# HCI_LE_Generate_DHKey_Complete
# TODO: b/265052417 - Definition needs to be added


struct LEEnhancedConnectionCompleteSubeventV1:
  -- 7.7.65.10 LE Enhanced Connection Complete event
  -- HCI_LE_Enhanced_Connection_Complete
  0     [+LEMetaEvent.$size_in_bytes]  LEMetaEvent         le_meta_event
  $next [+1]                           hci.StatusCode      status
  $next [+2]                           UInt                connection_handle
    [requires: 0x0000 <= this <= 0x0EFF]

  $next [+1]                           hci.ConnectionRole  role
  $next [+1]                           hci.LEAddressType   peer_address_type
  $next [+hci.BdAddr.$size_in_bytes]   hci.BdAddr          peer_address
  $next [+hci.BdAddr.$size_in_bytes]   hci.BdAddr          local_resolvable_private_address
  $next [+hci.BdAddr.$size_in_bytes]   hci.BdAddr          peer_resolvable_private_address
  $next [+2]                           UInt                connection_interval
    -- Time: N * 1.25 ms
    -- Range: 7.5 ms to 4 s
    [requires: 0x0006 <= this <= 0x0C80]

  $next [+2]                           UInt                peripheral_latency
    [requires: 0x0000 <= this <= 0x01F3]

  $next [+2]                           UInt                supervision_timeout
    -- Time: N * 10 ms
    -- Range: 100 ms to 32 s
    [requires: 0x000A <= this <= 0x0C80]

  $next [+1]                           LEClockAccuracy     central_clock_accuracy
    -- Only valid for a peripheral. On a central, this parameter shall be set to 0x00.

# 7.7.65.10 LE Enhanced Connection Complete event
# HCI_LE_Enhanced_Connection_Complete
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.11 LE Directed Advertising Report event
# HCI_LE_Directed_Advertising_Report
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.12 LE PHY Update Complete event
# HCI_LE_PHY_Update_Complete
# TODO: b/265052417 - Definition needs to be added


struct LEExtendedAdvertisingReportData:
  0     [+2]  bits:

    0     [+LEExtendedAdvertisingEventType.$size_in_bits]  LEExtendedAdvertisingEventType  event_type

  $next [+1]                                               hci.LEExtendedAddressType       address_type
    -- Address type of the advertiser.

  $next [+hci.BdAddr.$size_in_bytes]                       hci.BdAddr                      address
    -- Public Device Address, Random Device Address, Public Identity Address or
    -- Random (static) Identity Address of the advertising device.

  $next [+1]                                               hci.LEPrimaryAdvertisingPHY     primary_phy
    -- Indicates the PHY used to send the advertising PDU on the primary advertising
    -- channel. Legacy PDUs always use LE_1M. NONE, LE_2M, and LE_CODED_S2 are excluded.

  $next [+1]                                               hci.LESecondaryAdvertisingPHY   secondary_phy
    -- Indicates the PHY used to send the advertising PDU(s), if any, on the secondary
    -- advertising channel. A value of NONE means that no packets were received on the
    -- secondary advertising channel.

  $next [+1]                                               UInt                            advertising_sid
    -- Value of the Advertising SID subfield in the ADI field of the PDU. A value of
    -- 0xFF means no ADI field provided.
    [requires: 0x00 <= this <= 0x0F || this == 0xFF]

  $next [+1]                                               Int                             tx_power
    -- Units: dBm. A value of 0x7F means Tx Power information is not available.
    [requires: -127 <= this <= 20 || this == 0x7F]

  $next [+1]                                               Int                             rssi
    -- Units: dBm. A value of 0x7F means RSSI is not available.
    [requires: -127 <= this <= 20 || this == 0x7F]

  $next [+2]                                               UInt                            periodic_advertising_interval
    -- 0x0000: No periodic advertising.
    -- 0xXXXX:
    --   Time = N * 1.25 ms
    --   Time Range: 7.5 ms to 81,918.75 s
    [requires: 0x0006 <= this <= 0xFFFF || this == 0x0000]

  $next [+1]                                               LEDirectAddressType             direct_address_type

  $next [+hci.BdAddr.$size_in_bytes]                       hci.BdAddr                      direct_address
    -- TargetA field in the advertisement or either Public Identity Address or Random (static)
    -- Identity Address of the target device.

  $next [+1]                                               UInt                            data_length
    -- Length of the |data| field.

  $next [+data_length]                                     UInt:8[data_length]             data
    -- |data_length| octets of advertising or scan response data formatted as defined in
    -- [Vol 3] Part C, Section 11. Note: Each element of this array has a variable length.


struct LEExtendedAdvertisingReportSubevent(reports_size: UInt:8):
  -- 7.7.65.13 LE Extended Advertising Report event (v5.0) (LE)
  -- HCI_LE_Extended_Advertising_Report
  0     [+LEMetaEvent.$size_in_bytes]  LEMetaEvent           le_meta_event
  $next [+1]                           UInt                  num_reports
    -- Number of separate reports in the event.
    [requires: 0x01 <= this <= 0x0A]

  $next [+reports_size]                UInt:8[reports_size]  reports
    -- Since each report has a variable length, they are stored in a UInt:8 array.

# 7.7.65.14 LE Periodic Advertising Sync Established event
# HCI_LE_Periodic_Advertising_Sync_Established
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.15 LE Periodic Advertising Report event
# HCI_LE_Periodic_Advertising_Report
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.16 LE Periodic Advertising Sync Lost event
# HCI_LE_Periodic_Advertising_Sync_Lost
# TODO: b/265052417 - Definition needs to be added


struct LEScanTimeoutSubevent:
  -- 7.7.65.17 LE Scan Timeout event
  -- HCI_LE_Scan_Timeout
  0 [+LEMetaEvent.$size_in_bytes]  LEMetaEvent  le_meta_event

# 7.7.65.18 LE Advertising Set Terminated event
# HCI_LE_Advertising_Set_Terminated
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.19 LE Scan Request Received event
# HCI_LE_Scan_Request_Received
# TODO: b/265052417 - Definition needs to be added


struct LEChannelSelectionAlgorithmSubevent:
  -- 7.7.65.20 LE Channel Selection Algorithm event
  -- HCI_LE_Channel_Selection_Algorithm
  0     [+LEMetaEvent.$size_in_bytes]  LEMetaEvent                  le_meta_event
  $next [+2]                           UInt                         connection_handle
    -- Only the lower 12-bits are meaningful.
    [requires: 0x0000 <= this <= 0x0EFF]

  $next [+1]                           LEChannelSelectionAlgorithm  channel_selection_algorithm

# 7.7.65.21 LE Connectionless IQ Report event
# HCI_LE_Connectionless_IQ_Report
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.22 LE Connection IQ Report event
# HCI_LE_Connection_IQ_Report
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.23 LE CTE Request Failed event
# HCI_LE_CTE_Request_Failed
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.24 LE Periodic Advertising Sync Transfer Received event
# HCI_LE_Periodic_Advertising_Sync_Transfer_Received
# TODO: b/265052417 - Definition needs to be added


struct LECISEstablishedSubevent:
  -- 7.7.65.25 LE CIS Established event
  -- HCI_LE_CIS_Established

  0     [+LEMetaEvent.$size_in_bytes]  LEMetaEvent     le_meta_event

  $next [+1]                           hci.StatusCode  status

  $next [+2]                           UInt            connection_handle
    -- Connection handle of the CIS. Only the lower 12 bits are meaningful.
    [requires: 0x0000 <= 0x0EFF]

  $next [+3]                           UInt            cig_sync_delay
    -- The maximum time, in microseconds, for transmission of PDUs of all CISes
    -- in a CIG event.
    [requires: 0x0000EA <= 0x7FFFFF]

  $next [+3]                           UInt            cis_sync_delay
    -- The maximum time, in microseconds, for transmission of PDUs of the
    -- specified CIS in a CIG event.
    [requires: 0x0000EA <= 0x7FFFFF]

  $next [+3]                           UInt            transport_latency_c_to_p
    -- The actual transport latency, in microseconds, from Central to
    -- Peripheral.
    [requires: 0x0000EA <= 0x7FFFFF]

  $next [+3]                           UInt            transport_latency_p_to_c
    -- The actual transport latency, in microseconds, from Peripheral to
    -- Central.
    [requires: 0x0000EA <= 0x7FFFFF]

  $next [+1]                           IsoPhyType      phy_c_to_p
    -- PHY used by the Central to transmit

  $next [+1]                           IsoPhyType      phy_p_to_c
    -- PHY used by the Peripheral to transmit

  $next [+1]                           UInt            nse
    -- Maximum number of subevents in each CIS event
    [requires: 0x01 <= 0x1F]

  $next [+1]                           UInt            bn_c_to_p
    -- The burst number for Central to Peripheral transmission.
    -- 0 indicates no isochronous data from the Central to the Peripheral.
    [requires: 0x00 <= 0x0F]

  $next [+1]                           UInt            bn_p_to_c
    -- The burst number for Peripheral to Central transmission.
    -- 0 indicates no isochronous data from the Peripheral to the Central.
    [requires: 0x00 <= 0x0F]

  $next [+1]                           UInt            ft_c_to_p
    -- The flush timeout, in multiples of the ISO_Interval for the CIS, for each
    -- payload sent from the Central to the Peripheral.
    [requires: 0x01 <= 0xFF]

  $next [+1]                           UInt            ft_p_to_c
    -- The flush timeout, in multiples of the ISO_Interval for the CIS, for each
    -- payload sent from the Peripheral to the Central.
    [requires: 0x01 <= 0xFF]

  $next [+2]                           UInt            max_pdu_c_to_p
    -- Maximum size, in octets, of the payload from Central to Peripheral.
    [requires: 0x0000 <= 0x00FB]

  $next [+2]                           UInt            max_pdu_p_to_c
    -- Maximum size, in octets, of the payload from Peripheral to Central.
    [requires: 0x0000 <= 0x00FB]

  $next [+2]                           UInt            iso_interval
    -- The time between two consecutive CIS anchor points.
    -- Time = N * 1.25ms
    -- Time Range: 5ms to 4s
    [requires: 0x0004 <= 0x0C80]


struct LECISRequestSubevent:
  -- 7.7.65.26 LE CIS Request event
  -- HCI_LE_CIS_Request

  0     [+LEMetaEvent.$size_in_bytes]  LEMetaEvent  le_meta_event

  $next [+2]                           UInt         acl_connection_handle
    -- Only the lower 12 bits are meaningful.
    [requires: 0x0000 <= 0x0EFF]

  $next [+2]                           UInt         cis_connection_handle
    -- Only the lower 12 bits are meaningful.
    [requires: 0x0000 <= 0x0EFF]

  $next [+1]                           UInt         cig_id
    [requires: 0x00 <= 0xEF]

  $next [+1]                           UInt         cis_id
    [requires: 0x00 <= 0xEF]

# 7.7.65.27 LE Create BIG Complete event
# HCI_LE_Create_BIG_Complete
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.28 LE Terminate BIG Complete event
# HCI_LE_Terminate_BIG_Complete
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.29 LE BIG Sync Established event
# HCI_LE_BIG_Sync_Established
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.30 LE BIG Sync Lost event
# HCI_LE_BIG_Sync_Lost
# TODO: b/265052417 - Definition needs to be added


struct LERequestPeerSCACompleteSubevent:
  -- 7.7.65.31 LE Request Peer SCA Complete event
  -- HCI_LE_Request_Peer_SCA_Complete
  0     [+LEMetaEvent.$size_in_bytes]  LEMetaEvent                    le_meta_event
  $next [+1]                           hci.StatusCode                 status
  $next [+2]                           UInt                           connection_handle
    -- Connection handle of the ACL connection. Only the lower 12-bits are meaningful.
    [requires: 0x0000 <= this <= 0x0EFF]

  $next [+1]                           hci.LESleepClockAccuracyRange  peer_clock_accuracy

# 7.7.65.32 LE Path Loss Threshold event
# HCI_LE_Path_Loss_Threshold
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.33 LE Transmit Power Reporting event
# HCI_LE_Transmit_Power_Reporting
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.34 LE BIGInfo Advertising Report event
# HCI_LE_BIGInfo_Advertising_Report
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.35 LE Subrate Change event
# HCI_LE_Subrate_Change
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.36 LE Periodic Advertising Subevent Data Request event
# HCI_LE_Periodic_Advertising_Subevent_Data_Request
# TODO: b/265052417 - Definition needs to be added


# 7.7.65.37 LE Periodic Advertising Response Report event
# HCI_LE_Periodic_Advertising_Response_Report
# TODO: b/265052417 - Definition needs to be added


# 7.7.66 Triggered Clock Capture event
# HCI_Triggered_Clock_Capture
# TODO: b/265052417 - Definition needs to be added


# 7.7.67 Synchronization Train Complete event
# HCI_Synchronization_Train_Complete
# TODO: b/265052417 - Definition needs to be added


# 7.7.68 Synchronization Train Received event
# HCI_Synchronization_Train_Received
# TODO: b/265052417 - Definition needs to be added


# 7.7.69 Connectionless Peripheral Broadcast Receive event
# HCI_Connectionless_Peripheral_Broadcast_Receive
# TODO: b/265052417 - Definition needs to be added


# 7.7.70 Connectionless Peripheral Broadcast Timeout event
# HCI_Connectionless_Peripheral_Broadcast_Timeout
# TODO: b/265052417 - Definition needs to be added


# 7.7.71 Truncated Page Complete event
# HCI_Truncated_Page_Complete
# TODO: b/265052417 - Definition needs to be added


# 7.7.72 Peripheral Page Response Timeout event
# HCI_Peripheral_Page_Response_Timeout
# TODO: b/265052417 - Definition needs to be added


# 7.7.73 Connectionless Peripheral Broadcast Channel Map Change event
# HCI_Connectionless_Peripheral_Broadcast_Channel_Map_Change
# TODO: b/265052417 - Definition needs to be added


# 7.7.74 Inquiry Response Notification event
# HCI_Inquiry_Response_Notification
# TODO: b/265052417 - Definition needs to be added


# 7.7.75 Authenticated Payload Timeout Expired event
# HCI_Authenticated_Payload_Timeout_Expired
# TODO: b/265052417 - Definition needs to be added


# 7.7.76 SAM Status Change event
# HCI_SAM_Status_Change
# TODO: b/265052417 - Definition needs to be added
